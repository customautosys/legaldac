import T from"es-main";import{Command as W}from"commander";import w from"semver";import{XMLParser as V}from"fast-xml-parser";var _="legaldac",k="0.1.0",G="LEGAL-DAC (Programming Language)",Z={build:"tsc --noEmit && rollup --config rollup.config.ts --configPlugin @rollup/plugin-typescript"},$="dist/index.mjs",q="dist/index.mjs",z="https://github.com/customautosys/legaldac",B="Wilson Foo Yu Kang",K="NPOSL-3.0",Y="yarn@4.3.1",H={commander:"^12.1.0","es-main":"^1.3.0","fast-xml-parser":"^4.4.0","libarchive.js":"^2.0.2",semver:"^7.6.2"},J={"@rollup/plugin-json":"^6.1.0","@rollup/plugin-node-resolve":"^15.2.3","@rollup/plugin-typescript":"^11.1.6","@types/node":"^20.14.9","@types/semver":"^7",esbuild:"^0.23.0",rollup:"^4.18.0","rollup-plugin-dts":"^6.1.1","rollup-plugin-esbuild":"^6.1.1",tslib:"^2.6.3",typescript:"^5.5.2"},Q="module",U={import:"./dist/index.mjs",require:"./dist/index.cjs",types:"./dist/index.d.ts"},P={name:_,version:k,description:G,scripts:Z,main:$,bin:q,repository:z,author:B,license:K,packageManager:Y,dependencies:H,devDependencies:J,type:Q,exports:U};function C(){new W().version(P.version).name("legaldac").option("-d, --debug","enables verbose logging",!1).option("-v, --verbose","enables verbose logging",!1).argument("<input-filename>","the input filename").parse(process.argv)}class E{constructor(e){this.archiveFiles=e}getClauseIdentifier(e){let r="";if(typeof e.id!="string"&&(r+=`
Clause reference tag id must be a string`),w.validRange(e.version)||(r+=`
Clause reference tag id `+String(e.id)+" does not have a version attribute in the format [^]<number>.<number>.<number> or other valid semver range format"),r)throw new Error("Errors:"+r);let a=Object.keys(this.archiveFiles).filter(t=>t.startsWith(e.id+"@")&&!(this.archiveFiles[t]instanceof File));if(a.length<=0)throw new Error("No clause folders matching id "+e.id);a.sort((t,i)=>w.compare(t.split("@")[1],i.split("@")[1]));let o="";for(let t=a.length;--t>=0;)w.satisfies(a[t].split("@")[1],e.version)&&(o=a[t]);return o}async getClauseData(e){let r="",a=this.getClauseIdentifier(e);if(!a)throw new Error("No clause folders for "+e.id+" satisfying version "+e.version);let o=Object.keys(this.archiveFiles[a]).filter(n=>n.toLowerCase().endsWith(".lcxs"));if(o.length<1)throw new Error("No LCXS LEGAL-DAC Clause XML Script found");if(o.length>1)throw new Error("More than 1 LCXS LEGAL-DAC Clause XML Script found when only 1 is allowed");let t=null;this.archiveFiles[a][o[0]]instanceof File?t=this.archiveFiles[a][o[0]]:r+=`
Invalid file `+o[0];let i=Object.keys(this.archiveFiles[a]).filter(n=>n.toLowerCase().endsWith(".ts")||n.toLowerCase().endsWith(".js"));for(let n=i.length;--n>=0;)this.archiveFiles[a][i[n]]instanceof File||(r+=`
Invalid file `+i[n],i.splice(n,1));let l=await Promise.allSettled([...t?[t.text()]:[],...i.map(n=>this.archiveFiles[n].text())]);if(l.filter(n=>n.status==="rejected").forEach(n=>r+=`
`+n.status),r)throw new Error("Errors:"+r);return{identifier:a,xml:l[0].value,scripts:Object.fromEntries(l.slice(1).map((n,s)=>[i[s],n.value]))}}}var ee=Object.defineProperty,te=(u,e,r)=>e in u?ee(u,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[e]=r,v=(u,e,r)=>te(u,typeof e!="symbol"?e+"":e,r);const X=class j{constructor(){v(this,"parsedXml",[]),v(this,"version",""),v(this,"clauseReferences",[]),v(this,"clauseDatas",[]),v(this,"inputParameters",[]),v(this,"outputReturns",[])}async parse(e,r,a){let o="",t="",i=j.xmlParser.parse(e),l=i.filter(f=>f[a]);if(l.length<1)throw new Error("No root "+a+" tag");l.length>1&&(t+=`
More than 1 root `+a+" tag found when only 1 is allowed, only parsing 1st "+a+" tag");let n=String(l[0][":@"]?.version);w.valid(n)||(t+=`
All root `+a+" tags must have a version attribute in the format <number>.<number>.<number>");let s=String(l[0][":@"]?.legaldacversion);w.valid(s)||(t+=`
All root `+a+" tags must have a legaldacversion attribute in the format <number>.<number>.<number>"),w.gt(s,P.version)&&(t+=`
legaldacversion is newer than this version of LEGAL-DAC`);let c=l[0].document,h=c.filter(f=>f.clauses);h.length>1&&(t+="More than 1 clauses tag found under root "+a+" tag when at most 1 is allowed, only parsing 1st clauses tag");let L=[],y={};if(h.length>=1){let f=h[0].clauses.filter(p=>p.clause);(await Promise.allSettled(f.map(async p=>{let d={id:p[":@"]?.id,version:String(p[":@"]?.version)};return{clauseData:await r.getClauseData(d),clauseReference:d}}))).forEach(p=>{if(p.status==="fulfilled"){y[p.value.clauseData.identifier]=p.value.clauseData,L.push(p.value.clauseReference);return}o+=`
`+p.reason})}let g=[],b=null,O=c.filter(f=>f.generation);if(O.length<1&&(o+=`
No generation tag found`),O.length>1&&(t+=`
More than 1 generation tag found when only 1 is allowed, only parsing 1st generation tag`),O.length>=1){let f=O[0].generation.filter(p=>p.input);if(f.length>1&&(t+=`
More than 1 input tag found when at most 1 is allowed, only parsing 1st input tag`),f.length>=1){let p=f[0].input.filter(d=>d.parameter);if(p.length>=1)for(let d=0;d<p.length;++d){let m=p[d][":@"].name;if(typeof m!="string"||!m){o+=`
Invalid name of input parameter`;continue}if(g.findIndex(A=>A.name===m)>=0){t+=`
Duplicate input parameter `+m+", ignoring duplicates after 1st parameter tag";continue}let N="string";p[d][":@"].type==="number"||p[d][":@"].type==="boolean"?p[d][":@"].type="string":p[d][":@"].type!=="string"&&(t=`
Invalid type of input parameter `+m+", defaulting to string");let D=p[d].parameter.filter(A=>A["#text"]).map(A=>A["#text"]).join(" ");(typeof D!="string"||!D)&&(t+="Invalid prompt of input parameter "+m+", setting prompt to name",D=m),g.push({name:m,type:N,prompt:D})}}b=await this.parseOutput(O,i,g,r),o+=String(b.errors),t+=String(b.warnings)}if(b||(o+=`
No parsed output section`),o)throw new Error("Errors:"+o+`

Warnings:`+t);if(this.parsedXml=i,this.version=n,this.clauseReferences=L,this.inputParameters=g,b&&(this.outputReturns=b.outputReturns,this.setParseOutputReturn&&this.setParseOutputReturn(b)),t)return"Warnings:"+t}};v(X,"XML_PARSER_OPTIONS",{alwaysCreateTextNode:!0,preserveOrder:!0,ignoreAttributes:!1,allowBooleanAttributes:!0,processEntities:!0,htmlEntities:!0}),v(X,"xmlParser",new V(X.XML_PARSER_OPTIONS));let x=X;class I extends x{async parse(e,r){return super.parse(e,r,"clause")}async parseOutput(e,r,a,o){let t="",i="",l=[],n=e[0].generation.filter(c=>c.output);if(n.length<1&&(t+=`
No output tag found`),t)return{errors:t,warnings:i,outputReturns:l};n.length>1&&(i+=`
More than 1 output tag found when only 1 is allowed, only parsing 1st output tag`);let s=n[0].output.filter(c=>c.return);return s.length>2&&(t+=`
More than 2 return tags found when only either 1 or 2 are allowed`),s.length<1&&(t+=`
No return tags found`),s.length===2&&!((s[0]?.[":@"]?.type==="string"||!s[0]?.[":@"]?.type)&&s[1]?.[":@"]?.type==="OOXML"||(s[1]?.[":@"]?.type==="string"||!s[1]?.[":@"]?.type)&&s[0]?.[":@"]?.type==="OOXML")&&(t+=`
If there are 2 return tags in a clause, exactly 1 must have the type of string and 1 must have the type of OOXML`),s.length===1&&(s[0]?.[":@"]?.type!=="string"||!s[0]?.[":@"]?.type)&&s[0]?.[":@"]?.type!=="OOXML"&&(t+=`
The return type must be either string or OOXML`),s.filter(c=>!c?.[":@"]?.variable).length>0&&(t+=`
No variable specified in return tag`),t?{errors:t,warnings:i,outputReturns:l}:(l=s.map(c=>({type:c?.[":@"]?.type==="OOXML"?"OOXML":"string",variable:c[":@"].variable})),{errors:t,warnings:i,outputReturns:l})}}var re=Object.defineProperty,ne=(u,e,r)=>e in u?re(u,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[e]=r,R=(u,e,r)=>ne(u,typeof e!="symbol"?e+"":e,r);class S extends x{constructor(){super(...arguments),R(this,"outputDocumentTag",{type:"constant",value:""}),R(this,"returnAllInputs",!0),R(this,"returnAllVariables",!0)}async parse(e,r){return super.parse(e,r,"document")}async parseOutput(e,r,a,o){let t="",i="",l=[],n=e[0].generation.filter(g=>g.output);if(n.length<1&&(t+=`
No output tag found`),t)return{errors:t,warnings:i,outputReturns:l};n.length>1&&(i+=`
More than 1 output tag found when only 1 is allowed, only parsing 1st output tag`);let s=n[0]?.[":@"]?.returnAllInputs!=="false",c=n[0]?.[":@"]?.returnAllVariables!=="false",h=n[0].output.filter(g=>g.document);if(h.length<1&&(t+=`
No document tag found`),h.length>1&&(i+=`
More than 1 document tag found when only 1 is allowed, only parsing 1st document tag`),t)return{errors:t,warnings:i,outputReturns:l,returnAllInputs:s,returnAllVariables:c};if((!h[0]?.[":@"]?.constant&&h[0]?.[":@"]?.variable||String(h[0]?.[":@"]?.constant).toLowerCase().endsWith(".docx")&&!h[0]?.[":@"]?.variable)&&(t+=`
Document tag must either have a constant attribute which ends in .docx, or a variable attribute`),t)return{errors:t,warnings:i,outputReturns:l,returnAllInputs:s,returnAllVariables:c};let L={type:h[0]?.[":@"]?.variable?"variable":"constant",value:h[0]?.[":@"]?.variable?h[0][":@"].variable:h[0]?.[":@"]?.constant},y=n[0].output.filter(g=>g.return);return!s&&!c&&y.length<1&&(i+=`
No return tags found and neither returning all inputs nor returning all variables, nothing will be replaced`),y.filter(g=>g?.[":@"]?.type&&g?.[":@"]?.type!=="string"&&y[0]?.[":@"]?.type!=="OOXML")&&(t+=`
The return type must be either string or OOXML`),y.filter(g=>!g?.[":@"]?.variable).length>0&&(t+=`
No variable specified in return tag`),t?{errors:t,warnings:i,outputReturns:l,outputDocumentTag:L,returnAllInputs:s,returnAllVariables:c}:(l=y.map(g=>({type:g?.[":@"]?.type==="OOXML"?"OOXML":"string",variable:g[":@"].variable,...g?.[":@"]?.replace?{replace:g?.[":@"]?.replace}:{}})),{errors:t,warnings:i,outputReturns:l,outputDocumentTag:L,returnAllInputs:s,returnAllVariables:c})}setParseOutputReturn(e){e&&(this.outputReturns=e.outputReturns,e.outputDocumentTag&&(this.outputDocumentTag=e.outputDocumentTag),this.returnAllInputs=e.returnAllInputs!==!1,this.returnAllVariables=e.returnAllVariables!==!1)}}var ae=Object.defineProperty,ie=(u,e,r)=>e in u?ae(u,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[e]=r,M=(u,e,r)=>ie(u,typeof e!="symbol"?e+"":e,r);class F{constructor(){M(this,"file",null),M(this,"archive",null),M(this,"archiveFiles",null),M(this,"ldxs",null)}async load(e){this.file=e;let r=await(await(typeof window>"u"?import("libarchive.js/dist/libarchive-node.mjs"):import("libarchive.js"))).Archive.open(e),a=await r.extractFiles(),o=Object.keys(a).filter(l=>l.toLowerCase().endsWith(".ldxs")&&a[l]instanceof File);if(o.length<1)throw new Error("No LDXS LEGAL-DAC Document XML Script found");if(o.length>1)throw new Error("More than 1 LDXS LEGAL-DAC Document XML Script found when only 1 is allowed");let t=new S,i=a[o[0]];await t.parse(await i.text(),new E(a)),this.file=e,this.archive=r,this.archiveFiles=a,this.ldxs=t}}var se=Object.freeze({__proto__:null,ArchiveFolderClauseRepository:E,LegaldacClauseXmlScript:I,LegaldacDocument7Z:F,LegaldacDocumentXmlScript:S,LegaldacXmlScript:x,cli:C});T(import.meta)&&C();export{E as ArchiveFolderClauseRepository,I as LegaldacClauseXmlScript,F as LegaldacDocument7Z,S as LegaldacDocumentXmlScript,x as LegaldacXmlScript,C as cli,se as default};
//# sourceMappingURL=index.mjs.map
